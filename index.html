<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RRL Detective: Evidence ‚Üí Tentative Answer ‚Üí Research Gap</title>
  <style>
    :root{
      --bg:#f4f6f9; --card:#fff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
      --accent:#111827; --warn:#fffbeb; --warnLine:#f59e0b; --ok:#ecfdf5; --okLine:#10b981;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Arial, sans-serif;background:var(--bg);color:var(--ink)}
    header{background:var(--accent);color:#fff;padding:14px 18px;position:sticky;top:0;z-index:10}
    header .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    h1{margin:0;font-size:18px}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.12)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}

    .container{max-width:1200px;margin:0 auto;padding:16px}
    .grid{display:grid;gap:12px}
    .grid.cols{grid-template-columns:390px 1fr}
    @media (max-width:980px){.grid.cols{grid-template-columns:1fr}}

    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 1px 4px rgba(0,0,0,.06)}
    h2{margin:0 0 10px;font-size:16px}
    h3{margin:0 0 8px;font-size:14px}
    p{margin:8px 0;color:var(--muted);font-size:13px;line-height:1.45}
    hr{border:none;border-top:1px solid var(--line);margin:14px 0}

    button{border:0;border-radius:10px;padding:10px 12px;cursor:pointer;font-weight:700}
    button.primary{background:var(--accent);color:#fff}
    button.secondary{background:#e5e7eb;color:var(--ink)}
    button:disabled{opacity:.55;cursor:not-allowed}

    input[type="text"]{padding:10px 12px;border:1px solid var(--line);border-radius:10px;width:240px}

    .callout{
      border:1px solid var(--line);border-left:6px solid var(--accent);
      border-radius:12px;padding:10px 12px;background:#fff;
    }
    .callout b{font-size:13px}
    .callout ul{margin:8px 0 0;padding-left:18px;color:var(--muted);font-size:13px}
    .callout li{margin:4px 0}
    .miniDef{
      border:1px solid var(--line);border-radius:12px;padding:10px 12px;background:#fff;
      display:grid;gap:8px;
    }
    .miniDef .def{font-size:12px;color:var(--muted);line-height:1.4}
    .tag{font-size:11px;padding:3px 7px;border-radius:999px;background:#f3f4f6;color:var(--ink);display:inline-block;margin-right:6px;margin-top:6px}

    .twistBox{display:none;margin-top:10px;border:1px solid var(--warnLine);background:var(--warn);padding:10px 12px;border-radius:12px}
    .twistBox.show{display:block}

    .evidenceTray{min-height:120px;display:flex;flex-wrap:wrap;gap:10px;padding:10px;border:1px solid var(--line);border-radius:12px;background:#fff}
    .card{
      width:240px;background:#fff;border:1px solid var(--line);border-radius:12px;padding:10px;
      cursor:grab;box-shadow:0 1px 3px rgba(0,0,0,.06);user-select:none;position:relative;
    }
    .card:active{cursor:grabbing}
    .small{font-size:12px;color:var(--muted)}
    .pinBtn{
      position:absolute;top:8px;right:8px;border:1px solid var(--line);
      background:#fff;border-radius:10px;padding:6px 8px;font-size:12px;font-weight:700;cursor:pointer;
    }
    .pinned{outline:2px solid var(--okLine)}
    .pinned .pinBtn{background:var(--ok);border-color:var(--okLine)}

    .scoreBox{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:10px 0 12px}
    .metric{background:var(--accent);color:#fff;border-radius:12px;padding:10px 12px}
    .metric span{display:block;font-size:12px;opacity:.85}
    .metric b{display:block;font-size:16px;margin-top:2px}

    .board{display:grid;grid-template-columns:repeat(4, 1fr);gap:12px}
    @media (max-width:1100px){.board{grid-template-columns:repeat(2, 1fr)}}
    @media (max-width:720px){.board{grid-template-columns:1fr}}
    .bucket{
      min-height:230px;border:2px dashed #cbd5e1;border-radius:14px;padding:10px;background:#f8fafc;
    }
    .bucket.dragover{border-color:var(--accent);background:#eef2ff}
    .bucketTitle{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .bucketTitle b{font-size:13px}
    .pill{font-size:12px;padding:4px 8px;border-radius:999px;background:#e5e7eb;color:var(--ink)}
    .bucketInner{display:flex;flex-wrap:wrap;gap:10px}
    .hint{font-size:12px;color:var(--muted)}

    .choices{display:grid;gap:8px;margin-top:10px}
    .choice{padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#fff;cursor:pointer}
    .choice.selected{outline:2px solid var(--accent)}
    .choice small{color:var(--muted)}

    .toast{margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#fff;display:none}
  </style>
</head>
<body>
<header>
  <div class="row">
    <h1>üîé RRL Detective: Evidence ‚Üí Tentative Answer ‚Üí Research Gap</h1>
    <div class="badge" id="timerBadge">
      ‚è±Ô∏è <b>Game:</b> <span class="mono" id="gameTimer">20:00</span>
      &nbsp;|&nbsp; <b>Twist:</b> <span class="mono" id="twistTimer">10:00</span>
    </div>
  </div>
</header>

<div class="container">
  <div class="grid cols">

    <!-- LEFT -->
    <div class="panel">
      <h2>1) Load a Case (Timer starts automatically)</h2>
      <p>Click once. The 20-minute timer starts as soon as the case loads.</p>

      <input id="teamName" type="text" placeholder="Team name (optional)" />
      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
        <button class="primary" id="randCaseBtn" onclick="assignRandomCase()">üé≤ Load Random Case</button>
        <button class="secondary" onclick="resetAll()">Reset</button>
      </div>

      <div class="callout" style="margin-top:12px;">
        <b id="caseTitle">No case yet</b>
        <div class="small" id="caseSubtitle" style="margin-top:6px;">Load a case to begin.</div>
      </div>

      <div class="callout" style="margin-top:10px;">
        <b>Research Problem</b>
        <div class="small" id="problemText" style="margin-top:6px;">‚Äî</div>
      </div>

      <div class="callout" style="margin-top:10px;">
        <b>What your RRL must produce (click-based output)</b>
        <ul>
          <li>A <b>tentative answer</b> to the question (based on evidence patterns)</li>
          <li>A <b>research gap type</b>: theoretical, contextual, methodological (or combination)</li>
          <li>Evidence you ‚Äúpin‚Äù to justify your answer and gap</li>
        </ul>
      </div>

      <div class="miniDef" style="margin-top:10px;">
        <b>Gap Types (students learn these here)</b>
        <div class="def">
          <span class="tag">Theoretical gap</span> Missing concept, mechanism, or explanation; unclear ‚Äúwhy/how.‚Äù
        </div>
        <div class="def">
          <span class="tag">Contextual gap</span> Missing population/setting/time; unclear ‚Äúfor whom/where/when.‚Äù
        </div>
        <div class="def">
          <span class="tag">Methodological gap</span> Weak/limited methods or measures; unclear ‚Äúhow well we know.‚Äù
        </div>
      </div>

      <div class="twistBox" id="twistBox">
        <b>üö® Twist unlocked (10-minute mark)</b>
        <p class="small" id="twistText"></p>
        <button class="secondary" onclick="addTwistCards()">Add Twist Evidence</button>
      </div>

      <hr>

      <h2>2) Evidence Tray</h2>
      <p>Drag evidence into buckets. Cards can fit multiple buckets. That‚Äôs normal in RRL.</p>
      <div class="evidenceTray" id="tray" ondragover="allowDrop(event)" ondrop="dropToTray(event)"></div>
      <p class="hint">Tip: Click <b>Pin</b> on a card to use it as evidence for your final answers.</p>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <h2>Evidence Sorting Board</h2>

      <div class="scoreBox">
        <div class="metric"><span>Score</span><b id="scoreNum">0</b></div>
        <div class="metric"><span>Cards Sorted</span><b id="sortedNum">0</b></div>
        <div class="metric"><span>Pinned Evidence</span><b id="pinnedNum">0</b></div>
      </div>

      <div class="board">
        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'claimA')">
          <div class="bucketTitle"><b>üìå Supports Claim A</b><span class="pill" id="countA">0</span></div>
          <div class="bucketInner" id="innerA"></div>
          <p class="hint" id="claimAText">Load a case to see Claim A.</p>
        </div>

        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'claimB')">
          <div class="bucketTitle"><b>üìå Supports Claim B</b><span class="pill" id="countB">0</span></div>
          <div class="bucketInner" id="innerB"></div>
          <p class="hint" id="claimBText">Load a case to see Claim B.</p>
        </div>

        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'boundary')">
          <div class="bucketTitle"><b>üß≠ Boundary / Context</b><span class="pill" id="countC">0</span></div>
          <div class="bucketInner" id="innerC"></div>
          <p class="hint">Evidence that explains ‚Äúit depends‚Äù (population, setting, time, conditions).</p>
        </div>

        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'methods')">
          <div class="bucketTitle"><b>üß™ Method / Measurement Limits</b><span class="pill" id="countM">0</span></div>
          <div class="bucketInner" id="innerM"></div>
          <p class="hint">Evidence showing design weaknesses (cross-sectional, weak measures, missing comparisons).</p>
        </div>
      </div>

      <hr>

      <h2>Final Outputs (Click Only)</h2>
      <p>This is the RRL ‚Äúdeliverable‚Äù: tentative answer + gap type(s) + pinned evidence.</p>

      <h3>Tentative Answer</h3>
      <div class="choices" id="answerChoices"></div>

      <h3 style="margin-top:12px;">Gap Type(s)</h3>
      <div class="choices" id="gapChoices"></div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
        <button class="primary" onclick="submit()" id="submitBtn" disabled>Submit</button>
        <button class="secondary" onclick="hint()">Hint</button>
      </div>

      <div id="result" class="toast"></div>
    </div>

  </div>
</div>

<script>
/** ========= Timing ========= */
const TOTAL_SECONDS = 20 * 60;
const TWIST_UNLOCK_AT_REMAINING = 10 * 60; // unlock when remaining hits 10:00
let remaining = TOTAL_SECONDS;
let timer = null;
let started = false;

/** ========= State ========= */
let activeCase = null;
let twistUnlocked = false;
let twistAdded = false;
let answerPick = null;
let gapTypePicks = new Set();
let pinned = new Set(); // card ids
let score = 0;

/** ========= Cases =========
 * Evidence cards include:
 * - role tags: supports A/B, boundary/context, methods
 * - gapHints: theoretical/contextual/methodological (what they teach)
 * Cards can have multiple roles & multiple gapHints (ambiguity is realistic).
 */
const CASES = [
  {
    id: "socialmedia",
    title: "Case: Social Media Use & Academic Performance",
    subtitle: "You are advising a college on whether social media harms learning.",
    problem: "The college wants evidence-based guidance. Based on existing studies, what is the most reasonable tentative answer about social media and academic performance, and what gap should a new study address?",
    claimA: "Claim A: More social media use is linked to lower academic performance.",
    claimB: "Claim B: Social media use is not always harmful; effects depend on how it is used and context.",
    answerKey: "MIXED_DEPENDS", // used for scoring
    gapKey: ["CONTEXTUAL","METHODOLOGICAL"], // what good students should identify most
    cards: [
      { id:"S1", title:"Study 1 (College Survey)", text:"Higher daily use correlates with lower GPA among college students.", roles:["claimA"], gapHints:["METHODOLOGICAL"], meta:["Cross-sectional correlation"] },
      { id:"S2", title:"Study 2 (Private Universities)", text:"No significant link found in private universities; results differ from other samples.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Context: private-only"] },
      { id:"S3", title:"Study 3 (Engagement Type)", text:"Passive scrolling predicts poorer performance; active academic networking shows neutral/positive outcomes.", roles:["claimB","boundary"], gapHints:["THEORETICAL","CONTEXTUAL"], meta:["Mechanism: passive vs active"] },
      { id:"S4", title:"Study 4 (Measure Issue)", text:"Many studies measure 'screen time' but not the type or purpose of use.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Measurement limitation"] },
      { id:"S5", title:"Study 5 (Population Mismatch)", text:"Some findings are from high school samples and may not apply to college learning demands.", roles:["boundary"], gapHints:["CONTEXTUAL"], meta:["Population difference"] },
      { id:"S6", title:"Study 6 (Outdated Data)", text:"Older datasets (pre-2015) may not reflect current platforms or post-pandemic behavior.", roles:["boundary"], gapHints:["CONTEXTUAL"], meta:["Time/context shift"] },
      { id:"S7", title:"Study 7 (Design Limitation)", text:"Most studies are one-time surveys, limiting causal conclusions.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Need longitudinal/experimental"] },
      { id:"S8", title:"Study 8 (Why/How unclear)", text:"Few studies test mechanisms (sleep disruption, attention, stress) explaining the effect.", roles:["methods"], gapHints:["THEORETICAL"], meta:["Mechanism not tested"] },
    ],
    twist: {
      text: "New evidence arrives: A recent synthesis reports effects vary strongly by engagement type and study design quality.",
      cards: [
        { id:"ST1", title:"Twist (Meta-analysis)", text:"Overall effects are small-to-moderate but highly variable across engagement types and contexts.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Heterogeneity evidence"] },
        { id:"ST2", title:"Twist (Design Call)", text:"Better designs (longitudinal) show different patterns than cross-sectional surveys.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Design quality matters"] }
      ]
    }
  },
  {
    id: "digitalbank",
    title: "Case: Digital Loan Apps & Financial Inclusion",
    subtitle: "You are evaluating whether digital loan applications exclude low-income households.",
    problem: "A policy team asks: are digital loan applications financially inclusive for low-income households, or do they create barriers? What tentative answer is most reasonable, and what type of research gap remains?",
    claimA: "Claim A: Digital loan apps increase access for the previously unbanked.",
    claimB: "Claim B: Digital loan apps can exclude low-income users through process barriers (KYC, literacy, connectivity).",
    answerKey: "BOTH_TRUE_PROCESS_GAP",
    gapKey: ["METHODOLOGICAL","CONTEXTUAL"],
    cards: [
      { id:"D1", title:"Study 1 (Access Benefit)", text:"Digital lending expands access among previously unbanked applicants.", roles:["claimA"], gapHints:["CONTEXTUAL"], meta:["Who benefits: unbanked"] },
      { id:"D2", title:"Study 2 (Drop-off Point)", text:"Large applicant drop-off occurs during KYC document upload steps.", roles:["claimB","boundary"], gapHints:["METHODOLOGICAL"], meta:["Process bottleneck"] },
      { id:"D3", title:"Study 3 (Digital Literacy)", text:"Lower digital literacy predicts incomplete applications.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Skill barrier"] },
      { id:"D4", title:"Study 4 (Connectivity)", text:"Low-connectivity users are less likely to finish onboarding.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Infrastructure barrier"] },
      { id:"D5", title:"Study 5 (Outcome-only reporting)", text:"Most research reports approval rates but not reasons for rejection/abandonment.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Missing process evidence"] },
      { id:"D6", title:"Study 6 (Rural vs Urban missing)", text:"Few studies compare rural and urban applicants for the same product.", roles:["methods","boundary"], gapHints:["CONTEXTUAL"], meta:["Context comparison missing"] },
      { id:"D7", title:"Study 7 (Mechanism unclear)", text:"Studies rarely test how policy requirements interact with literacy and connectivity.", roles:["methods"], gapHints:["THEORETICAL"], meta:["Interaction mechanisms"] },
    ],
    twist: {
      text: "New policy update: stricter KYC increases abandonment among low-income applicants.",
      cards: [
        { id:"DT1", title:"Twist (Policy Update)", text:"Stricter KYC leads to higher abandonment among low-income applicants.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL","THEORETICAL"], meta:["Policy interaction clue"] }
      ]
    }
  }
];

/** ========= UI helpers ========= */
const el = (id)=>document.getElementById(id);
const fmt = (sec)=>`${String(Math.floor(sec/60)).padStart(2,"0")}:${String(sec%60).padStart(2,"0")}`;
function escapeHTML(str){ return (str||"").replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])); }

/** ========= Timer logic (auto-start when case loads) ========= */
function startTimerIfNeeded(){
  if (started) return;
  started = true;

  timer = setInterval(()=>{
    remaining -= 1;

    if (!twistUnlocked && remaining <= TWIST_UNLOCK_AT_REMAINING){
      unlockTwist();
    }
    if (remaining <= 0){
      remaining = 0;
      endGame();
    }
    updateTimers();
  }, 1000);

  updateTimers();
}
function updateTimers(){
  el("gameTimer").textContent = fmt(remaining);
  if (!twistUnlocked){
    const untilTwist = Math.max(remaining - TWIST_UNLOCK_AT_REMAINING, 0);
    el("twistTimer").textContent = fmt(untilTwist);
  } else {
    el("twistTimer").textContent = "UNLOCKED";
  }
}
function unlockTwist(){
  twistUnlocked = true;
  el("twistText").textContent = activeCase.twist.text;
  el("twistBox").classList.add("show");
  toast("üö® Twist unlocked. Add the new evidence and reconsider your tentative answer and gaps.");
}
function addTwistCards(){
  if (!twistUnlocked || twistAdded) return;
  activeCase.twist.cards.forEach(addCardToTray);
  twistAdded = true;
  toast("‚úÖ Twist evidence added.");
}
function endGame(){
  if (timer) clearInterval(timer);
  el("timerBadge").textContent = "‚è±Ô∏è Time is up. Submit now.";
  el("submitBtn").disabled = false;
  toast("‚è±Ô∏è Time is up. Submit your tentative answer + gap types with pinned evidence.");
}

/** ========= Case loading ========= */
function assignRandomCase(){
  if (started) { toast("‚ö†Ô∏è Game already started. Reset to load a new case."); return; }
  const idx = Math.floor(Math.random()*CASES.length);
  loadCase(CASES[idx].id);
}
function loadCase(caseId){
  activeCase = CASES.find(c=>c.id===caseId);

  // reset state
  twistUnlocked = false; twistAdded = false;
  answerPick = null; gapTypePicks = new Set();
  pinned = new Set(); score = 0;
  remaining = TOTAL_SECONDS;
  if (timer) clearInterval(timer);
  started = false;

  // render case info
  el("caseTitle").textContent = activeCase.title;
  el("caseSubtitle").textContent = activeCase.subtitle;
  el("problemText").textContent = activeCase.problem;
  el("claimAText").textContent = activeCase.claimA;
  el("claimBText").textContent = activeCase.claimB;

  // clear UI
  clearBoardAndTray();
  el("twistBox").classList.remove("show");

  // add initial evidence to tray immediately (so they can start interacting right away)
  activeCase.cards.forEach(addCardToTray);

  // render choices
  renderAnswerChoices();
  renderGapChoices();

  // enable submit once case is loaded
  el("submitBtn").disabled = false;

  // timer AUTO starts now
  startTimerIfNeeded();
  toast("‚úÖ Case loaded. Timer started. Sort evidence, pin key evidence, then choose a tentative answer + gap types.");
}

/** ========= Evidence cards ========= */
function addCardToTray(card){
  if (el("card_"+card.id)) return;

  const div = document.createElement("div");
  div.className = "card";
  div.id = "card_"+card.id;
  div.draggable = true;
  div.ondragstart = (e)=> e.dataTransfer.setData("text/plain", card.id);

  const rolesText = card.roles.map(r=>{
    if (r==="claimA") return `<span class="tag">Supports A</span>`;
    if (r==="claimB") return `<span class="tag">Supports B</span>`;
    if (r==="boundary") return `<span class="tag">Boundary/Context</span>`;
    if (r==="methods") return `<span class="tag">Method/Measure</span>`;
    return "";
  }).join("");

  const gapsText = card.gapHints.map(g=>{
    if (g==="THEORETICAL") return `<span class="tag">Theoretical clue</span>`;
    if (g==="CONTEXTUAL") return `<span class="tag">Contextual clue</span>`;
    if (g==="METHODOLOGICAL") return `<span class="tag">Methodological clue</span>`;
    return "";
  }).join("");

  div.innerHTML = `
    <button class="pinBtn" onclick="togglePin('${card.id}')">Pin</button>
    <b>${escapeHTML(card.title)}</b>
    <div class="small" style="margin-top:6px;">${escapeHTML(card.text)}</div>
    <div style="margin-top:8px;">${rolesText}</div>
    <div style="margin-top:6px;">${gapsText}</div>
    <div class="small" style="margin-top:6px;">${(card.meta||[]).map(m=>`‚Ä¢ ${escapeHTML(m)}`).join("<br>")}</div>
  `;
  el("tray").appendChild(div);
  updateMetrics();
}

function togglePin(cardId){
  const node = el("card_"+cardId);
  if (!node) return;
  if (pinned.has(cardId)){
    pinned.delete(cardId);
    node.classList.remove("pinned");
  } else {
    pinned.add(cardId);
    node.classList.add("pinned");
  }
  updateMetrics();
}

/** ========= Drag & drop buckets (not graded as ‚Äúright/wrong‚Äù) ========= */
function allowDrop(e){ e.preventDefault(); }
function bucketOver(e){ e.preventDefault(); e.currentTarget.classList.add("dragover"); }
function bucketLeave(e){ e.currentTarget.classList.remove("dragover"); }

function dropToTray(e){
  e.preventDefault();
  const id = e.dataTransfer.getData("text/plain");
  const cardEl = el("card_"+id);
  if (!cardEl) return;
  el("tray").appendChild(cardEl);
  updateCounts();
}
function dropToBucket(e, bucket){
  e.preventDefault();
  e.currentTarget.classList.remove("dragover");
  const id = e.dataTransfer.getData("text/plain");
  const cardEl = el("card_"+id);
  if (!cardEl) return;

  const dest = {
    claimA: el("innerA"),
    claimB: el("innerB"),
    boundary: el("innerC"),
    methods: el("innerM"),
  }[bucket];

  dest.appendChild(cardEl);
  updateCounts();
}

function updateCounts(){
  el("countA").textContent = el("innerA").children.length;
  el("countB").textContent = el("innerB").children.length;
  el("countC").textContent = el("innerC").children.length;
  el("countM").textContent = el("innerM").children.length;
  updateMetrics();
}

/** ========= Final choices ========= */
function renderAnswerChoices(){
  const wrap = el("answerChoices");
  wrap.innerHTML = "";

  // Universal answer options (click only)
  const options = [
    { id:"A_TRUE", label:"Tentative Answer: Claim A is mostly supported", desc:"Most evidence supports Claim A; limited boundary/method issues." },
    { id:"B_TRUE", label:"Tentative Answer: Claim B is mostly supported", desc:"Evidence suggests effects depend on conditions (context/type/constraints)." },
    { id:"MIXED_DEPENDS", label:"Tentative Answer: Mixed results, depends on context", desc:"Studies conflict; boundary conditions explain why findings differ." },
    { id:"INSUFFICIENT", label:"Tentative Answer: Evidence is insufficient for a clear conclusion", desc:"Too many method/measurement limitations to confidently conclude." },
    { id:"BOTH_TRUE_PROCESS_GAP", label:"Tentative Answer: Both can be true; process determines inclusion/exclusion", desc:"Some benefit exists, but process barriers exclude certain groups." },
  ];

  options.forEach(o=>{
    const div = document.createElement("div");
    div.className = "choice";
    div.id = "ans_"+o.id;
    div.innerHTML = `<b>${escapeHTML(o.label)}</b><br><small>${escapeHTML(o.desc)}</small>`;
    div.onclick = ()=>pickAnswer(o.id);
    wrap.appendChild(div);
  });
}

function pickAnswer(id){
  answerPick = id;
  [...document.querySelectorAll("#answerChoices .choice")].forEach(x=>x.classList.remove("selected"));
  const node = el("ans_"+id);
  if (node) node.classList.add("selected");
  updateMetrics();
}

function renderGapChoices(){
  const wrap = el("gapChoices");
  wrap.innerHTML = "";

  const opts = [
    { id:"THEORETICAL", label:"Theoretical gap", desc:"Mechanisms/constructs unclear (why/how effects happen)." },
    { id:"CONTEXTUAL", label:"Contextual gap", desc:"Population/setting/time missing or not compared (for whom/where/when)." },
    { id:"METHODOLOGICAL", label:"Methodological gap", desc:"Design/measurement weak (how well we know; causality; metrics)." },
  ];

  opts.forEach(o=>{
    const div = document.createElement("div");
    div.className = "choice";
    div.id = "gap_"+o.id;
    div.innerHTML = `<b>${escapeHTML(o.label)}</b><br><small>${escapeHTML(o.desc)}</small>`;
    div.onclick = ()=>toggleGapType(o.id);
    wrap.appendChild(div);
  });
}
function toggleGapType(id){
  if (gapTypePicks.has(id)){
    gapTypePicks.delete(id);
    el("gap_"+id).classList.remove("selected");
  } else {
    gapTypePicks.add(id);
    el("gap_"+id).classList.add("selected");
  }
  updateMetrics();
}

/** ========= Scoring (coherence-based, not strict classification) ========= */
function computeScore(){
  if (!activeCase) return 0;

  // Evidence-based heuristics:
  // - Encourage pinning
  // - Encourage picking answer that matches case answerKey
  // - Encourage choosing gap types that match case gapKey
  // - Encourage having enough ‚Äúmethods‚Äù or ‚Äúboundary‚Äù cards if claiming insufficient/depends
  let s = 0;

  // Pinning is important in RRL: evidence-backed arguments
  s += Math.min(pinned.size * 6, 36); // up to +36

  // Answer alignment
  if (answerPick){
    if (answerPick === activeCase.answerKey) s += 30;
    else s += 12; // they can still score for a plausible alternative
  }

  // Gap alignment (can be multiple)
  const key = new Set(activeCase.gapKey);
  let matches = 0;
  gapTypePicks.forEach(g=>{ if (key.has(g)) matches += 1; });
  s += matches * 15; // up to +30

  // Support coherence: if they chose "INSUFFICIENT", having more method-limit cards sorted helps
  const methodCount = el("innerM").children.length;
  const boundaryCount = el("innerC").children.length;
  if (answerPick === "INSUFFICIENT") s += Math.min(methodCount * 3, 15);
  if (answerPick === "MIXED_DEPENDS") s += Math.min(boundaryCount * 3, 15);
  if (answerPick === "BOTH_TRUE_PROCESS_GAP") s += Math.min(boundaryCount * 2, 10);

  // Twist bonus if unlocked and at least 1 twist card pinned (teaches updating synthesis)
  if (twistUnlocked){
    const pinnedTwist = [...pinned].some(id=>id.startsWith("ST") || id.startsWith("DT"));
    if (pinnedTwist) s += 10;
  }

  return s;
}

function updateMetrics(){
  const sorted = ["innerA","innerB","innerC","innerM"].reduce((acc,id)=> acc + el(id).children.length, 0);
  el("sortedNum").textContent = sorted;
  el("pinnedNum").textContent = pinned.size;

  score = computeScore();
  el("scoreNum").textContent = score;
}

/** ========= Submit ========= */
function submit(){
  if (!activeCase){ toast("‚ö†Ô∏è Load a case first."); return; }
  if (!answerPick){ toast("‚ö†Ô∏è Choose a tentative answer first."); return; }
  if (gapTypePicks.size === 0){ toast("‚ö†Ô∏è Select at least one gap type."); return; }
  if (pinned.size < 2){ toast("‚ö†Ô∏è Pin at least 2 evidence cards to support your answer."); return; }

  const team = (el("teamName").value||"").trim() || "Unnamed Team";
  const total = computeScore();
  const code = makeCode(team, total);

  const gapList = [...gapTypePicks].join(", ");

  el("result").style.display = "block";
  el("result").innerHTML = `
    <b>‚úÖ Submission Complete</b><br>
    <div class="small" style="margin-top:6px;">
      <b>Team:</b> ${escapeHTML(team)}<br>
      <b>Case:</b> ${escapeHTML(activeCase.title)}<br>
      <b>Tentative answer:</b> ${escapeHTML(answerPick)}<br>
      <b>Gap type(s):</b> ${escapeHTML(gapList)}<br>
      <b>Pinned evidence:</b> ${escapeHTML([...pinned].join(", "))}<br>
      <b>Score:</b> ${total}<br>
      <b>Shareable Code:</b> <span class="mono">${code}</span><br>
      <span class="hint">Send this code (or screenshot) to your instructor.</span>
    </div>
  `;
  el("result").scrollIntoView({behavior:"smooth", block:"start"});
}

function makeCode(team, total){
  const base = `${team}|${activeCase.id}|${total}|${Date.now()}`;
  let hash = 0;
  for (let i=0;i<base.length;i++){ hash = (hash*31 + base.charCodeAt(i)) >>> 0; }
  return `${activeCase.id.toUpperCase()}-${total}-${String(hash).slice(0,6)}`;
}

/** ========= Hint ========= */
function hint(){
  if (!activeCase){ toast("Hint: Load a random case."); return; }
  if (!answerPick){
    toast("Hint: Look at patterns. If evidence conflicts, choose a 'mixed/depends' answer and pin boundary evidence.");
    return;
  }
  if (gapTypePicks.size === 0){
    toast("Hint: Choose gap type(s). Method-limit cards push methodological gaps; population/time/context cards push contextual gaps; missing mechanism cards push theoretical gaps.");
    return;
  }
  if (pinned.size < 2){
    toast("Hint: Pin at least 2 cards that directly support your chosen answer and gap type(s).");
    return;
  }
  toast("Hint: Improve score by pinning twist evidence (after unlock) and making your answer consistent with the evidence pattern.");
}

/** ========= Reset ========= */
function clearBoardAndTray(){
  ["tray","innerA","innerB","innerC","innerM"].forEach(id=> el(id).innerHTML = "");
  el("countA").textContent = "0";
  el("countB").textContent = "0";
  el("countC").textContent = "0";
  el("countM").textContent = "0";
  el("result").style.display = "none";
  el("result").innerHTML = "";
  updateMetrics();
}
function resetAll(){
  if (timer) clearInterval(timer);
  // simplest reliable reset for a class activity:
  location.reload();
}

/** ========= Toast ========= */
function toast(html){
  const t = el("result");
  t.style.display = "block";
  t.innerHTML = html;
  t.scrollIntoView({behavior:"smooth", block:"start"});
}

/** ========= Initial timer display ========= */
el("gameTimer").textContent = fmt(remaining);
el("twistTimer").textContent = fmt(TWIST_UNLOCK_AT_REMAINING);

/** ========= Enable dragging targets ========= */
el("tray").addEventListener("dragover", allowDrop);

/** ========= Make buckets accept drops ========= */
function dropToBucket(e, which){
  e.preventDefault();
  e.currentTarget.classList.remove("dragover");
  const id = e.dataTransfer.getData("text/plain");
  const cardEl = el("card_"+id);
  if (!cardEl) return;
  const dest = {claimA:el("innerA"),claimB:el("innerB"),boundary:el("innerC"),methods:el("innerM")}[which];
  dest.appendChild(cardEl);
  updateCounts();
}
</script>
</body>
</html>
