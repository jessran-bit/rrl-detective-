<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RRL Detective: Evidence ‚Üí Tentative Answer ‚Üí Research Gap</title>
  <style>
    :root{
      --bg:#f4f6f9; --card:#fff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
      --accent:#111827; --warn:#fffbeb; --warnLine:#f59e0b; --ok:#ecfdf5; --okLine:#10b981;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Arial, sans-serif;background:var(--bg);color:var(--ink)}
    header{background:var(--accent);color:#fff;padding:14px 18px;position:sticky;top:0;z-index:10}
    header .row{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    h1{margin:0;font-size:18px}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.12)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}

    .container{max-width:1200px;margin:0 auto;padding:16px}
    .grid{display:grid;gap:12px}
    .grid.cols{grid-template-columns:390px 1fr}
    @media (max-width:980px){.grid.cols{grid-template-columns:1fr}}

    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 1px 4px rgba(0,0,0,.06)}
    h2{margin:0 0 10px;font-size:16px}
    h3{margin:0 0 8px;font-size:14px}
    p{margin:8px 0;color:var(--muted);font-size:13px;line-height:1.45}
    hr{border:none;border-top:1px solid var(--line);margin:14px 0}

    button{border:0;border-radius:10px;padding:10px 12px;cursor:pointer;font-weight:700}
    button.primary{background:var(--accent);color:#fff}
    button.secondary{background:#e5e7eb;color:var(--ink)}
    button:disabled{opacity:.55;cursor:not-allowed}

    input[type="text"]{padding:10px 12px;border:1px solid var(--line);border-radius:10px;width:240px}

    .callout{
      border:1px solid var(--line);border-left:6px solid var(--accent);
      border-radius:12px;padding:10px 12px;background:#fff;
    }
    .callout b{font-size:13px}
    .callout ul{margin:8px 0 0;padding-left:18px;color:var(--muted);font-size:13px}
    .callout li{margin:4px 0}
    .miniDef{
      border:1px solid var(--line);border-radius:12px;padding:10px 12px;background:#fff;
      display:grid;gap:10px;
    }
    .miniDef .def{font-size:12px;color:var(--muted);line-height:1.45}
    .tag{font-size:11px;padding:3px 7px;border-radius:999px;background:#f3f4f6;color:var(--ink);display:inline-block;margin-right:6px;margin-top:6px}

    .twistBox{display:none;margin-top:10px;border:1px solid var(--warnLine);background:var(--warn);padding:10px 12px;border-radius:12px}
    .twistBox.show{display:block}

    .evidenceTray{min-height:120px;display:flex;flex-wrap:wrap;gap:10px;padding:10px;border:1px solid var(--line);border-radius:12px;background:#fff}
    .card{
      width:240px;background:#fff;border:1px solid var(--line);border-radius:12px;padding:10px;
      cursor:grab;box-shadow:0 1px 3px rgba(0,0,0,.06);user-select:none;position:relative;
    }
    .card:active{cursor:grabbing}
    .small{font-size:12px;color:var(--muted)}
    .pinBtn{
      position:absolute;top:8px;right:8px;border:1px solid var(--line);
      background:#fff;border-radius:10px;padding:6px 8px;font-size:12px;font-weight:700;cursor:pointer;
    }
    .pinned{outline:2px solid var(--okLine)}
    .pinned .pinBtn{background:var(--ok);border-color:var(--okLine)}

    .scoreBox{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:10px 0 12px}
    .metric{background:var(--accent);color:#fff;border-radius:12px;padding:10px 12px}
    .metric span{display:block;font-size:12px;opacity:.85}
    .metric b{display:block;font-size:16px;margin-top:2px}

    .board{display:grid;grid-template-columns:repeat(4, 1fr);gap:12px}
    @media (max-width:1100px){.board{grid-template-columns:repeat(2, 1fr)}}
    @media (max-width:720px){.board{grid-template-columns:1fr}}
    .bucket{
      min-height:230px;border:2px dashed #cbd5e1;border-radius:14px;padding:10px;background:#f8fafc;
    }
    .bucket.dragover{border-color:var(--accent);background:#eef2ff}
    .bucketTitle{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .bucketTitle b{font-size:13px}
    .pill{font-size:12px;padding:4px 8px;border-radius:999px;background:#e5e7eb;color:var(--ink)}
    .bucketInner{display:flex;flex-wrap:wrap;gap:10px}
    .hint{font-size:12px;color:var(--muted)}

    .choices{display:grid;gap:8px;margin-top:10px}
    .choice{padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#fff;cursor:pointer}
    .choice.selected{outline:2px solid var(--accent)}
    .choice small{color:var(--muted)}

    .toast{margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:#fff;display:none}
  </style>
</head>
<body>
<header>
  <div class="row">
    <h1>üîé RRL Detective: Evidence ‚Üí Tentative Answer ‚Üí Research Gap</h1>
    <div class="badge" id="timerBadge">
      ‚è±Ô∏è <b>Game:</b> <span class="mono" id="gameTimer">20:00</span>
      &nbsp;|&nbsp; <b>Twist:</b> <span class="mono" id="twistTimer">15:00</span>
    </div>
  </div>
</header>

<div class="container">
  <div class="grid cols">

    <!-- LEFT -->
    <div class="panel">
      <h2>1) Load a Case (Timer starts automatically)</h2>
      <p>Click once. The 20-minute timer starts as soon as the case loads.</p>

      <input id="teamName" type="text" placeholder="Team name (optional)" />
      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
        <button class="primary" id="randCaseBtn" onclick="assignRandomCase()">üé≤ Load Random Case</button>
        <button class="secondary" onclick="resetAll()">Reset</button>
      </div>

      <div class="callout" style="margin-top:12px;">
        <b id="caseTitle">No case yet</b>
        <div class="small" id="caseSubtitle" style="margin-top:6px;">Load a case to begin.</div>
      </div>

      <div class="callout" style="margin-top:10px;">
        <b>Research Problem</b>
        <div class="small" id="problemText" style="margin-top:6px;">‚Äî</div>
      </div>

      <div class="callout" style="margin-top:10px;">
        <b>What your RRL must produce (click-based output)</b>
        <ul>
          <li>A <b>tentative answer</b> to the question (based on evidence patterns)</li>
          <li>A <b>research gap type</b>: theoretical, contextual, methodological (or combination)</li>
          <li>Evidence you ‚Äúpin‚Äù to justify your answer and gap</li>
        </ul>
      </div>

      <div class="miniDef" style="margin-top:10px;">
        <b>Types of Research Gaps</b>

        <div class="def">
          <span class="tag">Theoretical gap</span>
          A theoretical gap exists when current studies describe relationships or patterns but do not clearly explain the underlying mechanisms or concepts that drive those patterns.
          <br><br>
          Students should look for situations where research answers ‚Äúwhat is happening‚Äù but not ‚Äúwhy or how it happens.‚Äù
          <br><br>
          Examples include missing variables, unclear theoretical explanations, or lack of testing of proposed mechanisms.
        </div>

        <div class="def">
          <span class="tag">Contextual gap</span>
          A contextual gap exists when existing research findings may not apply across different populations, locations, time periods, or environments.
          <br><br>
          Students should look for situations where research results differ depending on who is studied, where the study is conducted, or when data was collected.
          <br><br>
          Examples include differences between rural and urban populations, different industries, generational differences, or outdated datasets.
        </div>

        <div class="def">
          <span class="tag">Methodological gap</span>
          A methodological gap exists when current studies use research designs, measurements, or procedures that limit confidence in their conclusions.
          <br><br>
          Students should look for evidence showing weaknesses such as cross-sectional surveys, weak measurement tools, missing comparison groups, or failure to capture important processes.
          <br><br>
          These gaps often indicate the need for stronger research designs such as longitudinal, experimental, or mixed-method approaches.
        </div>
      </div>

      <div class="twistBox" id="twistBox">
        <b>üö® Twist unlocked</b>
        <p class="small" id="twistText"></p>
        <button class="secondary" onclick="addTwistCards()">Add Twist Evidence</button>
      </div>

      <hr>

      <h2>2) Evidence Tray</h2>
      <p>Drag evidence into buckets. Cards can fit multiple buckets. That‚Äôs normal in RRL.</p>
      <div class="evidenceTray" id="tray" ondragover="allowDrop(event)" ondrop="dropToTray(event)"></div>
      <p class="hint">Tip: Click <b>Pin</b> on a card to use it as evidence for your final answers.</p>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <h2>Evidence Sorting Board</h2>

      <div class="scoreBox">
        <div class="metric"><span>Score</span><b id="scoreNum">0</b></div>
        <div class="metric"><span>Cards Sorted</span><b id="sortedNum">0</b></div>
        <div class="metric"><span>Pinned Evidence</span><b id="pinnedNum">0</b></div>
      </div>

      <div class="board">
        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'claimA')">
          <div class="bucketTitle"><b>üìå Supports Claim A</b><span class="pill" id="countA">0</span></div>
          <div class="bucketInner" id="innerA"></div>
          <p class="hint" id="claimAText">Load a case to see Claim A.</p>
        </div>

        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'claimB')">
          <div class="bucketTitle"><b>üìå Supports Claim B</b><span class="pill" id="countB">0</span></div>
          <div class="bucketInner" id="innerB"></div>
          <p class="hint" id="claimBText">Load a case to see Claim B.</p>
        </div>

        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'boundary')">
          <div class="bucketTitle"><b>üß≠ Boundary / Context</b><span class="pill" id="countC">0</span></div>
          <div class="bucketInner" id="innerC"></div>
          <p class="hint">Evidence that explains ‚Äúit depends‚Äù (population, setting, time, conditions).</p>
        </div>

        <div class="bucket" ondragover="bucketOver(event)" ondragleave="bucketLeave(event)" ondrop="dropToBucket(event, 'methods')">
          <div class="bucketTitle"><b>üß™ Method / Measurement Limits</b><span class="pill" id="countM">0</span></div>
          <div class="bucketInner" id="innerM"></div>
          <p class="hint">Evidence showing design weaknesses (cross-sectional, weak measures, missing comparisons, missing process data).</p>
        </div>
      </div>

      <hr>

      <h2>Final Outputs</h2>
      <p>Choose a tentative answer + gap type(s), then pin evidence to justify your reasoning.</p>

      <h3>Tentative Answer</h3>
      <div class="choices" id="answerChoices"></div>

      <h3 style="margin-top:12px;">Gap Type(s)</h3>
      <div class="choices" id="gapChoices"></div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
        <button class="primary" onclick="submit()" id="submitBtn" disabled>Submit</button>
        <button class="secondary" onclick="hint()">Hint</button>
      </div>

      <div id="result" class="toast"></div>
    </div>

  </div>
</div>

<script>
/** ========= Timing ========= */
const TOTAL_SECONDS = 20 * 60;
// Twist unlock at 5-minute mark (remaining time hits 05:00)
const TWIST_UNLOCK_AT_REMAINING = 5 * 60;

let remaining = TOTAL_SECONDS;
let timer = null;
let started = false;

/** ========= State ========= */
let activeCase = null;
let twistUnlocked = false;
let twistAdded = false;
let answerPick = null;
let gapTypePicks = new Set();
let pinned = new Set();
let score = 0;

/** ========= Cases ========= */
const CASES = [
  {
    id: "socialmedia",
    title: "Case: Social Media Use & Academic Performance",
    subtitle: "You are advising a college on whether social media harms learning.",
    problem: "The college wants evidence-based guidance. Based on existing studies, what is the most reasonable tentative answer about social media and academic performance, and what gap should a new study address?",
    claimA: "Claim A: More social media use is linked to lower academic performance.",
    claimB: "Claim B: Social media use is not always harmful; effects depend on how it is used and context.",
    answerKey: "MIXED_DEPENDS",
    gapKey: ["CONTEXTUAL","METHODOLOGICAL"],
    cards: [
      { id:"S1", title:"Study 1 (College Survey)", text:"Higher daily use correlates with lower GPA among college students.", roles:["claimA"], gapHints:["METHODOLOGICAL"], meta:["Cross-sectional correlation"] },
      { id:"S2", title:"Study 2 (Private Universities)", text:"No significant link found in private universities; results differ from other samples.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Context: private-only"] },
      { id:"S3", title:"Study 3 (Engagement Type)", text:"Passive scrolling predicts poorer performance; active academic networking shows neutral/positive outcomes.", roles:["claimB","boundary"], gapHints:["THEORETICAL","CONTEXTUAL"], meta:["Mechanism: passive vs active"] },
      { id:"S4", title:"Study 4 (Measure Issue)", text:"Many studies measure 'screen time' but not the type or purpose of use.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Measurement limitation"] },
      { id:"S5", title:"Study 5 (Population Mismatch)", text:"Some findings are from high school samples and may not apply to college learning demands.", roles:["boundary"], gapHints:["CONTEXTUAL"], meta:["Population difference"] },
      { id:"S6", title:"Study 6 (Outdated Data)", text:"Older datasets (pre-2015) may not reflect current platforms or post-pandemic behavior.", roles:["boundary"], gapHints:["CONTEXTUAL"], meta:["Time/context shift"] },
      { id:"S7", title:"Study 7 (Design Limitation)", text:"Most studies are one-time surveys, limiting causal conclusions.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Need longitudinal/experimental"] },
      { id:"S8", title:"Study 8 (Why/How unclear)", text:"Few studies test mechanisms (sleep disruption, attention, stress) explaining the effect.", roles:["methods"], gapHints:["THEORETICAL"], meta:["Mechanism not tested"] },
    ],
    twist: {
      text: "New evidence arrives: A recent synthesis reports effects vary strongly by engagement type and study design quality.",
      cards: [
        { id:"ST1", title:"Twist (Meta-analysis)", text:"Overall effects are small-to-moderate but highly variable across engagement types and contexts.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Heterogeneity evidence"] },
        { id:"ST2", title:"Twist (Design Call)", text:"Better designs (longitudinal) show different patterns than cross-sectional surveys.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Design quality matters"] }
      ]
    }
  },
  {
    id: "digitalbank",
    title: "Case: Digital Loan Apps & Financial Inclusion",
    subtitle: "You are evaluating whether digital loan applications exclude low-income households.",
    problem: "A policy team asks: are digital loan applications financially inclusive for low-income households, or do they create barriers? What tentative answer is most reasonable, and what type of research gap remains?",
    claimA: "Claim A: Digital loan apps increase access for the previously unbanked.",
    claimB: "Claim B: Digital loan apps can exclude low-income users through process barriers (KYC, literacy, connectivity).",
    answerKey: "BOTH_TRUE_PROCESS_GAP",
    gapKey: ["METHODOLOGICAL","CONTEXTUAL"],
    cards: [
      { id:"D1", title:"Study 1 (Access Benefit)", text:"Digital lending expands access among previously unbanked applicants.", roles:["claimA"], gapHints:["CONTEXTUAL"], meta:["Who benefits: unbanked"] },
      { id:"D2", title:"Study 2 (Drop-off Point)", text:"Large applicant drop-off occurs during KYC document upload steps.", roles:["claimB","boundary"], gapHints:["METHODOLOGICAL"], meta:["Process bottleneck"] },
      { id:"D3", title:"Study 3 (Digital Literacy)", text:"Lower digital literacy predicts incomplete applications.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Skill barrier"] },
      { id:"D4", title:"Study 4 (Connectivity)", text:"Low-connectivity users are less likely to finish onboarding.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL"], meta:["Infrastructure barrier"] },
      { id:"D5", title:"Study 5 (Outcome-only reporting)", text:"Most research reports approval rates but not reasons for rejection/abandonment.", roles:["methods"], gapHints:["METHODOLOGICAL"], meta:["Missing process evidence"] },
      { id:"D6", title:"Study 6 (Rural vs Urban missing)", text:"Few studies compare rural and urban applicants for the same product.", roles:["methods","boundary"], gapHints:["CONTEXTUAL"], meta:["Context comparison missing"] },
      { id:"D7", title:"Study 7 (Mechanism unclear)", text:"Studies rarely test how policy requirements interact with literacy and connectivity.", roles:["methods"], gapHints:["THEORETICAL"], meta:["Interaction mechanisms"] },
    ],
    twist: {
      text: "New policy update: stricter KYC increases abandonment among low-income applicants.",
      cards: [
        { id:"DT1", title:"Twist (Policy Update)", text:"Stricter KYC leads to higher abandonment among low-income applicants.", roles:["claimB","boundary"], gapHints:["CONTEXTUAL","THEORETICAL"], meta:["Policy interaction clue"] }
      ]
    }
  }
];

/** ========= UI helpers ========= */
const el = (id)=>document.getElementById(id);
const fmt = (sec)=>`${String(Math.floor(sec/60)).padStart(2,"0")}:${String(sec%60).padStart(2,"0")}`;
function escapeHTML(str){ return (str||"").replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[m])); }

/** ========= Timer logic (auto-start when case loads) ========= */
function startTimerIfNeeded(){
  if (started) return;
  started = true;

  timer = setInterval(()=>{
    remaining -= 1;

    if (!twistUnlocked && remaining <= TWIST_UNLOCK_AT_REMAINING){
      unlockTwist();
    }
    if (remaining <= 0){
      remaining = 0;
      endGame();
    }
    updateTimers();
  }, 1000);

  updateTimers();
}
function updateTimers(){
  el("gameTimer").textContent = fmt(remaining);
  if (!twistUnlocked){
    const untilTwist = Math.max(remaining - TWIST_UNLOCK_AT_REMAINING, 0);
    el("twistTimer").textContent = fmt(untilTwist);
  } else {
    el("twistTimer").textContent = "UNLOCKED";
  }
}
function unlockTwist(){
  twistUnlocked = true;
  el("twistText").textContent = activeCase.twist.text;
  el("twistBox").classList.add("show");
  toast("üö® Twist unlocked. Add the new evidence and reconsider your tentative answer and gaps.");
}
function addTwistCards(){
  if (!twistUnlocked || twistAdded) return;
  activeCase.twist.cards.forEach(addCardToTray);
  twistAdded = true;
  toast("‚úÖ Twist evidence added.");
}
function endGame(){
  if (timer) clearInterval(timer);
  el("timerBadge").textContent = "‚è±Ô∏è Time is up. Submit now.";
  el("submitBtn").disabled = false;
  toast("‚è±Ô∏è Time is up. Submit your tentative answer + gap types with pinned evidence.");
}

/** ========= Case loading ========= */
function assignRandomCase(){
  if (started) { toast("‚ö†Ô∏è Game already started. Reset to load a new case."); return; }
  const idx = Math.floor(Math.random()*CASES.length);
  loadCase(CASES[idx].id);
}
function loadCase(caseId){
  activeCase = CASES.find(c=>c.id===caseId);

  // reset state
  twistUnlocked = false; twistAdded = false;
  answerPick = null; gapTypePicks = new Set();
  pinned = new Set(); score = 0;
  remaining = TOTAL_SECONDS;
  if (timer) clearInterval(timer);
  started = false;

  // render case info
  el("caseTitle").textContent = activeCase.title;
  el("caseSubtitle").textContent = activeCase.subtitle;
  el("problemText").textContent = activeCase.problem;
  el("claimAText").textContent = activeCase.claimA;
  el("claimBText").textContent = activeCase.claimB;

  // clear UI
  clearBoardAndTray();
  el("twistBox").classList.remove("show");

  // add initial evidence to tray immediately
  activeCase.cards.forEach(addCardToTray);

  // render choices
  renderAnswerChoices();
  renderGapChoices();

  // enable submit once case is loaded
  el("submitBtn").disabled = false;

  // timer AUTO starts now
  startTimerIfNeeded();
  toast("‚úÖ Case loaded. Timer started. Sort evidence, pin key evidence, then choose a tentative answer + gap types.");
}

/** ========= Evidence cards ========= */
function addCardToTray(card){
  if (el("card_"+card.id)) return;

  const div = document.createElement("div");
  div.className = "card";
  div.id = "card_"+card.id;
  div.draggable = true;
  div.ondragstart = (e)=> e.dataTransfer.setData("text/plain", card.id);

  const rolesText = card.roles.map(r=>{
    if (r==="claimA") return `<span class="tag">Supports A</span>`;
    if (r==="claimB") return `<span class="tag">Supports B</span>`;
    if (r==="boundary") return `<span class="tag">Boundary/Context</span>`;
    if (r==="methods") return `<span class="tag">Method/Measure</span>`;
    return "";
  }).join("");

  const gapsText = card.gapHints.map(g=>{
    if (g==="THEORETICAL") return `<span class="tag">Theoretical clue</span>`;
    if (g==="CONTEXTUAL") return `<span class="tag">Contextual clue</span>`;
    if (g==="METHODOLOGICAL") return `<span class="tag">Methodological clue</span>`;
    return "";
  }).join("");

  div.innerHTML = `
    <button class="pinBtn" onclick="togglePin('${card.id}')">Pin</button>
    <b>${escapeHTML(card.title)}</b>
    <div class="small" style="margin-top:6px;">${escapeHTML(card.text)}</div>
    <div style="margin-top:8px;">${rolesText}</div>
    <div style="margin-top:6px;">${gapsText}</div>
    <div class="small" style="margin-top:6px;">${(card.meta||[]).map(m=>`‚Ä¢ ${escapeHTML(m)}`).join("<br>")}</div>
  `;
  el("tray").appendChild(div);
  updateMetrics();
}

function togglePin(cardId){
  const node = el("card_"+cardId);
  if (!node) return;
  if (pinned.has(cardId)){
    pinned.delete(cardId);
    node.classList.remove("pinned");
  } else {
    pinned.add(cardId);
    node.classList.add("pinned");
  }
  updateMetrics();
}

/** ========= Drag & drop ========= */
function allowDrop(e){ e.preventDefault(); }
function bucketOver(e){ e.preventDefault(); e.currentTarget.classList.add("dragover"); }
function bucketLeave(e){ e.currentTarget.classList.remove("dragover"); }

function dropToTray(e){
  e.preventDefault();
  const id = e.dataTransfer.getData("text/plain");
  const cardEl = el("card_"+id);
  if (!cardEl) return;
  el("tray").appendChild(cardEl);
  updateCounts();
}
function dropToBucket(e, which){
  e.preventDefault();
  e.currentTarget.classList.remove("dragover");
  const id = e.dataTransfer.getData("text/plain");
  const cardEl = el("card_"+id);
  if (!cardEl) return;

  const dest = {claimA:el("innerA"),claimB:el("innerB"),boundary:el("innerC"),methods:el("innerM")}[which];
  dest.appendChild(cardEl);
  updateCounts();
}

function updateCounts(){
  el("countA").textContent = el("innerA").children.length;
  el("countB").textContent = el("innerB").children.length;
  el("countC").textContent = el("innerC").children.length;
  el("countM").textContent = el("innerM").children.length;
  updateMetrics();
}

/** ========= Final choices ========= */
function renderAnswerChoices(){
  const wrap = el("answerChoices");
  wrap.innerHTML = "";

  const options = [
    { id:"A_TRUE", label:"Claim A is mostly supported", desc:"Most evidence points to Claim A, with few boundary/method issues." },
    { id:"B_TRUE", label:"Claim B is mostly supported", desc:"Evidence suggests effects depend on conditions (context/type/constraints)." },
    { id:"MIXED_DEPENDS", label:"Mixed results, depends on context", desc:"Studies conflict; boundary conditions help explain differences." },
    { id:"INSUFFICIENT", label:"Evidence is insufficient for a clear conclusion", desc:"Too many method/measurement limitations to conclude confidently." },
    { id:"BOTH_TRUE_PROCESS_GAP", label:"Both can be true; the process determines outcomes", desc:"Some benefit exists, but process barriers exclude certain groups." },
  ];

  options.forEach(o=>{
    const div = document.createElement("div");
    div.className = "choice";
    div.id = "ans_"+o.id;
    div.innerHTML = `<b>${escapeHTML(o.label)}</b><br><small>${escapeHTML(o.desc)}</small>`;
    div.onclick = ()=>pickAnswer(o.id);
    wrap.appendChild(div);
  });
}
function pickAnswer(id){
  answerPick = id;
  [...document.querySelectorAll("#answerChoices .choice")].forEach(x=>x.classList.remove("selected"));
  const node = el("ans_"+id);
  if (node) node.classList.add("selected");
  updateMetrics();
}

function renderGapChoices(){
  const wrap = el("gapChoices");
  wrap.innerHTML = "";

  const opts = [
    { id:"THEORETICAL", label:"Theoretical gap", desc:"Mechanisms/constructs unclear (why/how effects happen)." },
    { id:"CONTEXTUAL", label:"Contextual gap", desc:"Population/setting/time missing or not compared (for whom/where/when)." },
    { id:"METHODOLOGICAL", label:"Methodological gap", desc:"Design/measurement weak (how well we know; causality; metrics)." },
  ];

  opts.forEach(o=>{
    const div = document.createElement("div");
    div.className = "choice";
    div.id = "gap_"+o.id;
    div.innerHTML = `<b>${escapeHTML(o.label)}</b><br><small>${escapeHTML(o.desc)}</small>`;
    div.onclick = ()=>toggleGapType(o.id);
    wrap.appendChild(div);
  });
}
function toggleGapType(id){
  if (gapTypePicks.has(id)){
    gapTypePicks.delete(id);
    el("gap_"+id).classList.remove("selected");
  } else {
    gapTypePicks.add(id);
    el("gap_"+id).classList.add("selected");
  }
  updateMetrics();
}

/** ========= Scoring (coherence-based) ========= */
function computeScoreBreakdown(){
  if (!activeCase){
    return { total:0, pinScore:0, answerScore:0, gapScore:0, coherenceBonus:0, twistBonus:0, gapMatches:0, breakdownLines:[] };
  }

  let breakdown = [];
  let total = 0;

  // Evidence pins
  const pinScore = Math.min(pinned.size * 6, 36);
  total += pinScore;
  breakdown.push(`Evidence support: ${pinScore} points (Pinned ${pinned.size} evidence cards)`);

  // Answer alignment
  let answerScore = 0;
  if (answerPick){
    if (answerPick === activeCase.answerKey){
      answerScore = 30;
      breakdown.push(`Tentative answer: 30 points (Best-supported synthesis for this case)`);
    } else {
      answerScore = 12;
      breakdown.push(`Tentative answer: 12 points (Plausible, but not the strongest synthesis given the evidence)`);
    }
  } else {
    breakdown.push(`Tentative answer: 0 points (No answer selected)`);
  }
  total += answerScore;

  // Gap alignment
  const key = new Set(activeCase.gapKey);
  let gapMatches = 0;
  gapTypePicks.forEach(g=>{ if (key.has(g)) gapMatches++; });
  const gapScore = gapMatches * 15;
  total += gapScore;
  breakdown.push(`Gap identification: ${gapScore} points (${gapMatches} strong gap type matches)`);

  // Coherence bonus
  let coherenceBonus = 0;
  const boundaryCount = el("innerC").children.length;
  const methodCount = el("innerM").children.length;

  if (answerPick === "INSUFFICIENT"){
    coherenceBonus = Math.min(methodCount * 3, 15);
  }
  if (answerPick === "MIXED_DEPENDS"){
    coherenceBonus = Math.min(boundaryCount * 3, 15);
  }
  if (answerPick === "BOTH_TRUE_PROCESS_GAP"){
    coherenceBonus = Math.min(boundaryCount * 2, 10);
  }
  if (coherenceBonus > 0){
    breakdown.push(`Synthesis coherence bonus: ${coherenceBonus} points`);
  }
  total += coherenceBonus;

  // Twist bonus
  let twistBonus = 0;
  if (twistUnlocked){
    const pinnedTwist = [...pinned].some(id=>id.startsWith("ST") || id.startsWith("DT"));
    if (pinnedTwist){
      twistBonus = 10;
      breakdown.push(`Twist integration bonus: 10 points`);
      total += twistBonus;
    }
  }

  return { total, pinScore, answerScore, gapScore, coherenceBonus, twistBonus, gapMatches, breakdownLines: breakdown };
}

function computeScore(){
  return computeScoreBreakdown().total;
}

function updateMetrics(){
  const sorted = ["innerA","innerB","innerC","innerM"].reduce((acc,id)=> acc + el(id).children.length, 0);
  el("sortedNum").textContent = sorted;
  el("pinnedNum").textContent = pinned.size;

  score = computeScore();
  el("scoreNum").textContent = score;
}

/** ========= Submit ========= */
function submit(){
  if (!activeCase){ toast("‚ö†Ô∏è Load a case first."); return; }
  if (!answerPick){ toast("‚ö†Ô∏è Choose a tentative answer first."); return; }
  if (gapTypePicks.size === 0){ toast("‚ö†Ô∏è Select at least one gap type."); return; }
  if (pinned.size < 2){ toast("‚ö†Ô∏è Pin at least 2 evidence cards to support your answer."); return; }

  const team = (el("teamName").value||"").trim() || "Unnamed Team";
  const { total, breakdownLines } = computeScoreBreakdown();
  const code = makeCode(team, total);
  const gapList = [...gapTypePicks].join(", ");

  el("result").style.display = "block";
  el("result").innerHTML = `
    <b>‚úÖ Submission Complete</b><br>
    <div class="small" style="margin-top:6px;">
      <b>Team:</b> ${escapeHTML(team)}<br>
      <b>Case:</b> ${escapeHTML(activeCase.title)}<br>
      <b>Tentative answer:</b> ${escapeHTML(answerPick)}<br>
      <b>Gap type(s):</b> ${escapeHTML(gapList)}<br>
      <b>Pinned evidence:</b> ${escapeHTML([...pinned].join(", "))}<br>
      <b>Total Score:</b> ${total}<br><br>

      <b>Score Breakdown</b><br>
      ${breakdownLines.map(b=>`‚Ä¢ ${escapeHTML(b)}`).join("<br>")}<br><br>

      <b>Shareable Code:</b> <span class="mono">${code}</span><br>
      <span class="hint">Send this code (or screenshot) to your instructor.</span>
    </div>
  `;
  el("result").scrollIntoView({behavior:"smooth", block:"start"});
}

/** ========= Hint ========= */
function hint(){
  if (!activeCase){ toast("Hint: Load a random case."); return; }
  if (!answerPick){
    toast("Hint: Choose a tentative answer. If evidence conflicts, try 'Mixed results' or 'Both can be true'.");
    return;
  }
  if (gapTypePicks.size === 0){
    toast("Hint: Select gap type(s). Method-limit cards point to methodological gaps; population/time/context cards point to contextual gaps; missing mechanisms point to theoretical gaps.");
    return;
  }
  if (pinned.size < 2){
    toast("Hint: Pin at least 2 evidence cards that directly support your answer and gap type(s).");
    return;
  }
  if (twistUnlocked && !twistAdded){
    toast("Hint: Twist is unlocked. Add twist evidence and pin at least one twist card for a bonus.");
    return;
  }
  toast("Hint: Improve score by pinning stronger evidence and matching your synthesis to the overall pattern of studies.");
}

/** ========= Reset ========= */
function clearBoardAndTray(){
  ["tray","innerA","innerB","innerC","innerM"].forEach(id=> el(id).innerHTML = "");
  el("countA").textContent = "0";
  el("countB").textContent = "0";
  el("countC").textContent = "0";
  el("countM").textContent = "0";
  el("result").style.display = "none";
  el("result").innerHTML = "";
  updateMetrics();
}
function resetAll(){
  if (timer) clearInterval(timer);
  location.reload();
}

/** ========= Toast ========= */
function toast(html){
  const t = el("result");
  t.style.display = "block";
  t.innerHTML = html;
  t.scrollIntoView({behavior:"smooth", block:"start"});
}

/** ========= Case loading + timer auto-start ========= */
function assignRandomCase(){
  if (started) { toast("‚ö†Ô∏è Game already started. Reset to load a new case."); return; }
  const idx = Math.floor(Math.random()*CASES.length);
  loadCase(CASES[idx].id);
}
function loadCase(caseId){
  activeCase = CASES.find(c=>c.id===caseId);

  // reset state
  twistUnlocked = false; twistAdded = false;
  answerPick = null; gapTypePicks = new Set();
  pinned = new Set(); score = 0;
  remaining = TOTAL_SECONDS;
  if (timer) clearInterval(timer);
  started = false;

  // render case info
  el("caseTitle").textContent = activeCase.title;
  el("caseSubtitle").textContent = activeCase.subtitle;
  el("problemText").textContent = activeCase.problem;
  el("claimAText").textContent = activeCase.claimA;
  el("claimBText").textContent = activeCase.claimB;

  // clear UI
  clearBoardAndTray();
  el("twistBox").classList.remove("show");

  // add initial evidence to tray
  activeCase.cards.forEach(addCardToTray);

  // render choices
  renderAnswerChoices();
  renderGapChoices();

  // enable submit once case is loaded
  el("submitBtn").disabled = false;

  // timer auto-start
  startTimerIfNeeded();
  toast("‚úÖ Case loaded. Timer started. Sort evidence, pin key evidence, then choose a tentative answer + gap types.");
}

function startTimerIfNeeded(){
  if (started) return;
  started = true;

  timer = setInterval(()=>{
    remaining -= 1;

    if (!twistUnlocked && remaining <= TWIST_UNLOCK_AT_REMAINING){
      unlockTwist();
    }
    if (remaining <= 0){
      remaining = 0;
      endGame();
    }
    updateTimers();
  }, 1000);

  updateTimers();
}

function updateTimers(){
  el("gameTimer").textContent = fmt(remaining);
  if (!twistUnlocked){
    const untilTwist = Math.max(remaining - TWIST_UNLOCK_AT_REMAINING, 0);
    el("twistTimer").textContent = fmt(untilTwist);
  } else {
    el("twistTimer").textContent = "UNLOCKED";
  }
}

function unlockTwist(){
  twistUnlocked = true;
  el("twistText").textContent = activeCase.twist.text;
  el("twistBox").classList.add("show");
  toast("üö® Twist unlocked. Add the new evidence and reconsider your tentative answer and gaps.");
}

function addTwistCards(){
  if (!twistUnlocked || twistAdded) return;
  activeCase.twist.cards.forEach(addCardToTray);
  twistAdded = true;
  toast("‚úÖ Twist evidence added.");
}

/** ========= Utilities ========= */
function makeCode(team, total){
  const base = `${team}|${activeCase.id}|${total}|${Date.now()}`;
  let hash = 0;
  for (let i=0;i<base.length;i++){ hash = (hash*31 + base.charCodeAt(i)) >>> 0; }
  return `${activeCase.id.toUpperCase()}-${total}-${String(hash).slice(0,6)}`;
}

/** ========= Initial timer display ========= */
el("gameTimer").textContent = fmt(remaining);
el("twistTimer").textContent = fmt(TOTAL_SECONDS - TWIST_UNLOCK_AT_REMAINING);
</script>
</body>
</html>
